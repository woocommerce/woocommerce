name: Send a Slack notification when a PR contains rest api changes

on:
  pull_request_target:
    types: [labeled]

permissions: {}

jobs:
  send-slack-notification-when-pr-contains-rest-api-changes:
    if: "${{ github.event.label.name == 'contains: rest api change' && (github.event.pull_request.state == 'open' || github.event.pull_request.merged) }}"
    runs-on: ubuntu-20.04
    steps:
      - name: Wait 20sec for other labelling jobs to finish
        run: sleep 10
        shell: bash

      - name: Calculate test date
        id: calculate_date
        run: |
          #!/bin/bash
          
          # Get the day of the week of the merged PR (0 for Sunday, 1 for Monday, etc.)
          MERGE_DAY_OF_WEEK=$(date -u -d "${{ github.event.pull_request.merged_at }}" +"%u")
          
          # Calculate days until the next Thursday after the merge
          # If the merge is on Thursday, this will give 7 (i.e., next week's Thursday)
          DAYS_UNTIL_NEXT_THURSDAY=$(( (4 + 7 - MERGE_DAY_OF_WEEK) % 7 ))
          
          # If DAYS_UNTIL_NEXT_THURSDAY is 0, the merge was on a Thursday, so we set it to 7 to get the next Thursday
          if [ $DAYS_UNTIL_NEXT_THURSDAY -eq 0 ]; then
            DAYS_UNTIL_NEXT_THURSDAY=7
          fi
          
          # Calculate the date for the next Thursday after the merge
          THURSDAY_AFTER_MERGE=$(date -u -d "${{ github.event.pull_request.merged_at }} + $DAYS_UNTIL_NEXT_THURSDAY days" +"%Y-%m-%d")
          WOOAF_RELEASE_DATE=$(date -u -d "${THURSDAY_AFTER_MERGE} + 5 days" +"%Y-%m-%d")
          TEST_DATE_MESSAGE="Thursday, $THURSDAY_AFTER_MERGE. (Targeting release on $WOOAF_RELEASE_DATE)"
          echo "TEST_DATE_MESSAGE=${TEST_DATE_MESSAGE}" >> $GITHUB_ENV

      - name: Determine Milestone Date
        id: get_milestone_date
        run: |
          #!/bin/bash

          #
          # Generate Array with Milestones and dates
          #
          
          # Function to calculate the second Tuesday of the given month and year
          # as the release day is always the 2nd Tuesday
          calculate_second_tuesday() {
            year=$1
            month=$2
            # Check OS and adjust `date` command accordingly
            if [[ "$OSTYPE" == "darwin"* ]]; then
              # macOS version (BSD date)
              # Find the first Tuesday of the month
              first_of_month="$year-$month-01"
              day_of_week=$(date -j -f "%Y-%m-%d" "$first_of_month" "+%u")
              offset_to_first_tuesday=$(( (9 - day_of_week) % 7 ))
              first_tuesday=$(date -j -v+"$offset_to_first_tuesday"d -f "%Y-%m-%d" "$first_of_month" "+%Y-%m-%d")
              # Calculate the second Tuesday by adding 7 days to the first Tuesday
              second_tuesday=$(date -j -v+7d -f "%Y-%m-%d" "$first_tuesday" "+%Y-%m-%d")
            else
              # Linux version (GNU date)
              first_of_month="$year-$month-01"
              day_of_week=$(date -d "$first_of_month" "+%u")
              offset_to_first_tuesday=$(( (9 - day_of_week) % 7 ))
              first_tuesday=$(date -d "$first_of_month +$offset_to_first_tuesday days" "+%Y-%m-%d")
              # Calculate the second Tuesday by adding 7 days
              second_tuesday=$(date -d "$first_tuesday +7 days" "+%Y-%m-%d")
            fi
            echo $second_tuesday
          }
          
          # Set the initial values for version calculation
          initial_version_major=8  # Major version start
          initial_version_minor=8  # Minor version start
          initial_year=2024
          initial_month=4  # April, for the 8.8.0 release
          
          # Assuming the script is run in or after 2024
          current_year=$(date +%Y) # Get the current year
          echo "current_year: $current_year" 
          
          # Calculate the number of versions to generate based on the current year
          additional_versions=$(( (current_year - 2024 + 1) * 12 ))
          echo "additional_versions: $additional_versions"
          
          # Versions to calculate
          versions_to_calculate=$additional_versions
          echo "versions_to_calculate: $versions_to_calculate"

          # Declare the associative array outside the loop
          declare -A MILESTONE_DATES
          
          for (( i=0; i<versions_to_calculate; i++ )); do
            # Calculate year and month offset
            offset_year=$(( (initial_month + i - 1) / 12 ))
            echo "offset_year: $offset_year"
            current_year=$(( initial_year + offset_year ))
            echo "current_year: $current_year"
            current_month=$(( (initial_month + i - 1) % 12 + 1 ))
            echo "current_month: $current_month"
          
            # Format current month correctly
            current_month_formatted=$(printf "%02d" $current_month)
            echo "current_month_formatted: $current_month_formatted"
          
            # Calculate the release date
            release_date=$(calculate_second_tuesday $current_year $current_month_formatted)
            echo "release_date: $release_date"
          
            # Calculate the total versions from start, adjusting for starting at 8.8.0
            total_versions_from_start=$(( i + initial_version_minor ))
            echo "total_versions_from_start: $total_versions_from_start"
          
            # Adjust version major and minor calculations
            version_major=$(( initial_version_major + total_versions_from_start / 10 ))
            echo "version_major: $version_major"
            version_minor=$(( total_versions_from_start % 10 ))
            echo "version_minor: $version_minor"
          
            # Construct version string
            version="$version_major.$version_minor.0"
            echo "version: $version"

            # Populate the associative array with version as key and release_date as value
            MILESTONE_DATES["$version"]=$release_date
          
            echo "Version $version will be released on $release_date"
          
          done     
          
          MILESTONE_TITLE="${{ github.event.pull_request.milestone.title }}"
          MILESTONE_DATE="Undefined"
          
          # Check if the milestone title exists in our predefined list and get the date
          if [[ -v "MILESTONE_DATES[${MILESTONE_TITLE}]" ]]; then
            MILESTONE_DATE=${MILESTONE_DATES[${MILESTONE_TITLE}]}
          fi
          
          # Export for later steps
          echo "MILESTONE_DATE=${MILESTONE_DATE}" >> $GITHUB_ENV

          # If you need to print the array in the desired format for debugging
          echo "MILESTONE_DATES=("
          for version in "${!MILESTONE_DATES[@]}"; do
            echo "  [\"$version\"]=\"${MILESTONE_DATES[$version]}\""
          done
          echo ")"

      # Notify Slack Step
      - name: Notify Slack
        uses: archive/github-actions-slack@d9dae40827adf93bddf939db6552d1e392259d7d
        id: notify
        with:
            slack-bot-user-oauth-access-token: ${{ secrets.TEST_ASSISTANCE_BOT_TOKEN }}
            slack-channel: ${{ secrets.WOO_CORE_REST_API_CHANGES_SLACK_CHANNEL }}
            slack-text: |
                <${{ github.event.pull_request.html_url }}|${{ github.event.pull_request.title }}>
                *Labels:* ${{ join(github.event.pull_request.labels.*.name, ', ') }}
                *Monthly Release Milestone:* <${{ github.event.pull_request.milestone.html_url }}|${{ github.event.pull_request.milestone.title }}> (Release Date: ${{ env.MILESTONE_DATE }})
                *WooAF (weekly) Timeline: this PR can be tested from:* ${{ env.TEST_DATE_MESSAGE }}
                Please visit the <#${{ secrets.WOO_CORE_RELEASES_SLACK_CHANNEL }}> to obtain the latest WooAF build for testing.
            slack-optional-unfurl_links: false
            slack-optional-unfurl_media: false

