<?php

namespace Automattic\WooCommerce\Internal\Utilities;

use Automattic\WooCommerce\Internal\RegisterHooksInterface;
use Automattic\WooCommerce\Internal\Traits\AccessiblePrivateMethods;

/**
 * This class allows installing a plugin programmatically.
 *
 * Information about plugins installed in that way will be stored in a 'woocommerce_autoinstalled_plugins' option,
 * and a notice will be shown under the plugin name in the plugins list indicating that it was automatically
 * installed (these notices can be disabled with the 'woocommerce_show_autoinstalled_plugin_notices' hook).
 *
 * Currently it's only possible to install new plugins, not to upgrade or reinstall already installed plugins.
 *
 * The 'upgrader_process_complete' hook is used to remove the autoinstall information from any plugin that is later
 * upgraded or reinstalled by any means other than the usage of this class.
 */
class PluginInstaller implements RegisterHooksInterface {

	use AccessiblePrivateMethods;

	/**
	 * Flag indicating that a plugin install is in progress, so the upgrader_process_complete hook must be ignored.
	 *
	 * @var bool
	 */
	private bool $installing_plugin = false;

	/**
	 * Attach hooks used by the class.
	 */
	public function register() {
		self::add_action( 'after_plugin_row', array( $this, 'handle_plugin_list_rows' ), 10, 2 );
		self::add_action( 'upgrader_process_complete', array( $this, 'handle_upgrader_process_complete' ), 10, 2 );
	}

	/**
	 * Programmatically installs a plugin. Upgrade/reinstall of already existing plugins is not supported.
	 *
	 * $metadata can contain anything, but the following keys are recognized by the code that renders the notice
	 * in the plugins list:
	 *
	 * - 'installed_by': defaults to 'WooCommerce' if not present.
	 * - 'info_link': if present, a "More information" link will be included in the notice.
	 *
	 * Additionally, $metadata can contain a 'plugin_name' key to be used to check if the plugin installed
	 * successfully; if not present, the plugin name will be inferred from the diff of the installed plugins list
	 * before and after the installation process.
	 *
	 * Information about plugins successfully installed with this method will be kept in an option named
	 * 'woocommerce_autoinstalled_plugins'. Keys will be the plugin name and values will be associative arrays
	 * with these keys: 'plugin_name', 'version', 'date' and 'metadata' (same meaning as in the returned array).
	 *
	 * A log entry will be created with the result of the process and all the installer messages
	 * (source: 'plugin_auto_installs'). In multisite this log entry will be created on each site.
	 *
	 * The returned array will contain the following (only 'install_ok' and 'messages' if the installation fails):
	 *
	 * - 'install_ok', a boolean.
	 * - 'messages', all the messages generated by the installer.
	 * - 'plugin_name', useful if it wasn't supplied in $metadata.
	 * - 'version', of the plugin that has been installed.
	 * - 'date', ISO-formatted installation date.
	 * - 'metadata', as supplied (except the 'plugin_name' key) and only if not empty.
	 *
	 * @param string $plugin_url URL or file path of the plugin to install.
	 * @param array  $metadata Metadata to store if the installation succeeds.
	 * @return array Information about the installation result.
	 */
	public function install_plugin( string $plugin_url, array $metadata = array() ): array {
		$this->installing_plugin = true;
		try {
			return $this->install_plugin_core( $plugin_url, $metadata );
		} finally {
			$this->installing_plugin = false;
		}
	}

	/**
	 * Core version of 'install_plugin' (it doesn't handle the $installing_plugin flag).
	 *
	 * @param string $plugin_url URL or file path of the plugin to install.
	 * @param array  $metadata Metadata to store if the installation succeeds.
	 * @return array Information about the installation result.
	 */
	private function install_plugin_core( string $plugin_url, array $metadata ): array {
		wp_clean_plugins_cache();

		$plugin_name = $metadata['plugin_name'] ?? null;
		unset( $metadata['plugin_name'] );
		if ( is_null( $plugin_name ) ) {
			$old_plugin_names = array_keys( get_plugins() );
		} elseif ( ! is_null( $this->get_installed_plugin_info( $plugin_name ) ) ) {
			return array(
				'install_ok'         => false,
				'installer_messages' => __( 'Plugin is already installed', 'woocommerce' ),
			);
		}

		include_once ABSPATH . 'wp-admin/includes/file.php';
		include_once ABSPATH . 'wp-admin/includes/misc.php';
		include_once ABSPATH . 'wp-admin/includes/class-wp-upgrader.php';
		include_once ABSPATH . 'wp-admin/includes/class-automatic-upgrader-skin.php';
		$skin     = new \Automatic_Upgrader_Skin();
		$upgrader = new \Plugin_Upgrader( $skin );

		$install_ok = $upgrader->install( $plugin_url );
		wp_clean_plugins_cache();
		$result = array( 'messages' => $skin->get_upgrade_messages() );
		if ( $install_ok ) {
			$new_plugins      = get_plugins();
			$new_plugin_names = array_keys( $new_plugins );
			if ( is_null( $plugin_name ) ) {
				$diff_plugins = array_diff( $new_plugin_names, $old_plugin_names );
				if ( empty( $diff_plugins ) ) {
					$install_ok = false;
				} else {
					$plugin_name    = current( $diff_plugins );
					$plugin_version = $new_plugins[ $plugin_name ]['Version'];
				}
			} else {
				$plugin_info = $new_plugins[ $plugin_name ] ?? null;
				if ( is_null( $plugin_info ) ) {
					$install_ok = false;
				} else {
					$plugin_version = $plugin_info['Version'];
				}
			}
		}

		$installed_by = $metadata['installed_by'] ?? 'WooCommerce';
		if ( $install_ok ) {
			$result['plugin_name'] = $plugin_name;
			$plugin_data           = array(
				'version' => $plugin_version,
				'date'    => current_time( 'mysql' ),
			);
			if ( ! empty( $metadata ) ) {
				$plugin_data['metadata'] = $metadata;
			}

			$post_install = function () use ( $plugin_name, $plugin_version, $installed_by, $plugin_url, $plugin_data ) {
				$auto_installed_plugins                 = get_option( 'woocommerce_autoinstalled_plugins', array() );
				$auto_installed_plugins[ $plugin_name ] = $plugin_data;
				$log_context                            = array( 'source' => 'plugin_auto_installs', 'recorded_data' => $plugin_data );
				update_option( 'woocommerce_autoinstalled_plugins', $auto_installed_plugins );
				wc_get_logger()->info( "Plugin $plugin_name v{$plugin_version} installed by $installed_by, source: $plugin_url", $log_context );
			};
		} else {
			$messages     = $skin->get_upgrade_messages();
			$post_install = function () use ( $plugin_name, $plugin_url, $installed_by, $messages ) {
				$log_context   = array(
					'source'             => 'plugin_auto_installs',
					'installer_messages' => $messages,
				);
				$plugin_name ??= '';
				wc_get_logger()->error( "$installed_by failed to install plugin {$plugin_name} from source: $plugin_url", $log_context );
			};
		}

		$this->run_callback_in_all_sites( $post_install );

		$result['install_ok'] = $install_ok ?? false;
		return $result;
	}

	/**
	 * Get the information provided by 'get_plugins' for a given plugin.
	 * The returned array will also contain an extra boolean key, '_is_active_.
	 *
	 * @param string $plugin_name The name of the plugin to get information for.
	 * @return array|null An array with plugin information, or null if no plugin is installed with that name.
	 */
	private function get_installed_plugin_info( string $plugin_name ): ?array {
		wp_clean_plugins_cache();

		$plugin_name = plugin_basename( $plugin_name );
		$all_plugins = get_plugins();

		$plugin_info = $all_plugins[ $plugin_name ] ?? null;
		if ( is_null( $plugin_info ) ) {
			return null;
		}

		$plugin_info['_is_active'] = in_array( $plugin_name, array_map( 'plugin_basename', wp_get_active_and_valid_plugins() ), true );
		return $plugin_info;
	}

	/**
	 * Run a callback in each existing site (if multisite) or just once (if single site).
	 *
	 * @param callable $callback The callback to run.
	 */
	private static function run_callback_in_all_sites( callable $callback ) {
		if ( ! is_multisite() ) {
			$callback();
			return;
		}

		foreach ( get_sites() as $site ) {
			switch_to_blog( $site->blog_id );
			try {
				$callback();
			} finally {
				restore_current_blog();
			}
		}
	}

	/**
	 * Handler for the 'plugin_list_rows' hook, it will display a notice under the name of the plugins
	 * that have been installed using this class (unless the 'woocommerce_show_autoinstalled_plugin_notices' filter
	 * returns false) in the plugins list page.
	 *
	 * @param string $plugin_file Name of the plugin.
	 * @param array  $plugin_data Plugin data.
	 */
	private function handle_plugin_list_rows( $plugin_file, $plugin_data ) {
		global $wp_list_table;

		if ( is_null( $wp_list_table ) ) {
			return;
		}

		/**
		 * Filter to suppress the notice about autoinstalled plugins in the plugins list page.
		 *
		 * @since 8.8.0
		 *
		 * @param bool $display_notice Whether notices should be displayed or not.
		 * @returns bool
		 */
		if ( ! apply_filters( 'woocommerce_show_autoinstalled_plugin_notices', '__return_true' ) ) {
			return;
		}

		$auto_installed_plugins_info = get_option( 'woocommerce_autoinstalled_plugins', array() );
		$current_plugin_info         = $auto_installed_plugins_info[ $plugin_file ] ?? null;
		if ( is_null( $current_plugin_info ) || $current_plugin_info['version'] !== $plugin_data['Version'] ) {
			return;
		}

		$installed_by = $current_plugin_info['metadata']['installed_by'] ?? 'WooCommerce';
		$info_link    = $current_plugin_info['metadata']['info_link'] ?? null;
		if ( $info_link ) {
			/* translators: 1 = who installed the plugin, 2 = ISO-formatted date and time, 3 = URL */
			$message = sprintf( __( 'Plugin installed by %1$s on %2$s. <a target="_blank" href="%3$s">More information</a>', 'woocommerce' ), $installed_by, $current_plugin_info['date'], $info_link );
		} else {
			/* translators: 1 = who installed the plugin, 2 = ISO-formatted date and time */
			$message = sprintf( __( 'Plugin installed by %1$s on %2$s.', 'woocommerce' ), $installed_by, $current_plugin_info['date'] );
		}

		$columns_count      = $wp_list_table->get_column_count();
		$is_active          = is_plugin_active( $plugin_file );
		$is_active_class    = $is_active ? 'active' : 'inactive';
		$is_active_td_style = $is_active ? "style='border-left: 4px solid #72aee6;'" : '';

		// phpcs:disable WordPress.Security.EscapeOutput.OutputNotEscaped
		?>
		<tr class='plugin-update-tr update <?php echo $is_active_class; ?>' data-plugin='<?php echo $plugin_file; ?>' data-plugin-row-type='feature-incomp-warn'>
			<td colspan='<?php echo $columns_count; ?>' class='plugin-update'<?php echo $is_active_td_style; ?>>
				<div class='notice inline notice-success notice-alt'>
					<p>
						ℹ️ <?php echo $message; ?>
					</p>
				</div>
			</td>
		</tr>
		<?php
		// phpcs:enable WordPress.Security.EscapeOutput.OutputNotEscaped
	}

	/**
	 * Handler for the 'upgrader_process_complete' hook. It's used to remove the autoinstalled plugin information
	 * for plugins that are upgraded or reinstalled manually (or more generally, by using any install method
	 * other than this class).
	 *
	 * @param \WP_Upgrader $upgrader The upgrader class that has performed the plugin upgrade/reinstall.
	 * @param array        $hook_extra Extra information about the upgrade process.
	 */
	private function handle_upgrader_process_complete( \WP_Upgrader $upgrader, array $hook_extra ) {
		if ( $this->installing_plugin || ! ( $upgrader instanceof \Plugin_Upgrader ) || ( 'plugin' !== ( $hook_extra['type'] ?? null ) ) ) {
			return;
		}

		$auto_installed_plugins = get_option( 'woocommerce_autoinstalled_plugins' );
		if ( ! $auto_installed_plugins ) {
			return;
		}

		if ( $hook_extra['bulk'] ?? false ) {
			$updated_plugin_names = $hook_extra['plugins'] ?? array();
		} else {
			$updated_plugin_names = array( $upgrader->plugin_info() );
		}

		$auto_installed_plugin_names         = array_keys( $auto_installed_plugins );
		$updated_auto_installed_plugin_names = array_intersect( $auto_installed_plugin_names, $updated_plugin_names );

		if ( empty( $updated_auto_installed_plugin_names ) ) {
			return;
		}

		$new_auto_installed_plugins = array_diff_key( $auto_installed_plugins, array_flip( $updated_auto_installed_plugin_names ) );

		if ( empty( $new_auto_installed_plugins ) ) {
			delete_option( 'woocommerce_autoinstalled_plugins' );
		} else {
			update_option( 'woocommerce_autoinstalled_plugins', $new_auto_installed_plugins );
		}
	}
}
